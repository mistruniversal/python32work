"""Библиотека Threading позволяет разбросать задачи на потоки процессора
то есть чтобы код не выполнялся друг за другом а распредилялся на несколько путей"""
import threading
import time


"""Первый пример по факту просто привезали один поток к этой функции 
lock=threading.Lock() - это запись это класс который как раз позволяет запускать код в однопоточном режиме"""
# lock=threading.Lock()
# def score():
#     with lock:
#         for i in range(100000):
#             (i*2)**3
#         print("КОНЕЦ1")



"""Сдесь по сути тоже самое только мы при помощи lock.acquire() блокируем один поток от вторжения из вне ну или что бы его никто не занимал а
lock.release() разблокировывает его"""
# lock=threading.Lock()
# def score():
#     lock.acquire()
#     for i in range(100000):
#         (i*2)**3
#     print("КОНЕЦ1")
#     lock.release()





"""Есть еще RLock, или "рекурсивная блокировка", — это специальный тип блокировки
 в Python, который позволяет одному и тому же потоку захватывать блокировку
 несколько раз без возникновения взаимной блокировки (deadlock).
 
 По факту пишеться так-lock=threading.RLock()"""
# lock=threading.RLock()
# def score():
#     d1=time.time()
#     d2=time.time()
#     with lock:
#         for i in range(100000):
#             (i*2)**3
#         print("КОНЕЦ1")



"""класс Semaphore. Этот класс предоставляет механизм синхронизации, который позволяет 
ограничивать количество потоков, имеющих доступ к определенному ресурсу.

В двух словах класс который выделяет потоки на выполнение


acquire(blocking=True, timeout=-1) эта запись обозначает что blocking типо разрешение на блокировку может быть False или True 
ТОНКОСТЬ если поток который мы хотим заблочить уже заблокирован другим методом то он вернет значение False
timeout- это время в секундах, в течение которого поток будет ждать, чтобы получить доступ к семафору

и release() просто разблокировка

Заметка не забывать в классе Semaphore прописывать value=
"""

# semaphone1=threading.Semaphore(value=4)
# def score():
#     with semaphone1:
#         d1=time.time()
#         for i in range(100000):
#             (i*2)**3
#         d2=time.time()
#         print("КОНЕЦ1",d2-d1)
#
#
# semaphone2=threading.Semaphore(value=1)
# def score1():
#     semaphone2.acquire(blocking=True,timeout=-1)
#     d1=time.time()
#     for i in range(100000):
#         (i*2)**3
#     d2=time.time()
#     print("КОНЕЦ2",d2-d1)
#     semaphone2.release()
# """Заметка Скорость немножко разниться """
# score()
# score1()














"""Event Когда вы создаете объект Event, он изначально находится в состоянии "не установлен" (unset)"""
import threading
import time

# Создаем объект Event
event = threading.Event()


"""Объяснить будет трудно но код идеально подходит


в двух словах мы создали функцию и посередине ее выполнения мы при помощи
 even.wait() ставим ее на паузу
 в дальнейшем при выполнения кода при помощи 
 
 
 event.set() мы продолжаем ну или будим ее что бы функция дальше отробатывала
 
 
 is_set()-это просто проверка спит(False) евент или работает(True)
 
 
 Есть еще event.wait(timeout=None) просто по факту таймер ожидания
если стоит стоит None то просто будет ждать пока его не разбудят
если стоит любое другое float или int значение то это через сколько секунд он автоматом сам себя разбудит"""
def worker():
    print('Поток ожидает установки события...\n')
    event.wait()  # Ожидаем, пока событие не будет установлено
    print('Событие установлено! Поток продолжает выполнение.')

# Создаем и запускаем поток
thread = threading.Thread(target=worker)
thread.start()

# Имитация работы основного потока
print(event.is_set())
print('Основной поток работает...')
time.sleep(2)  # Ждем 2 секунды
print('Устанавливаем событие.')
event.set()  # Устанавливаем событие
print(event.is_set())

# Ждем завершения потока
thread.join()
print('Поток завершил работу.')

"""Примечание Если нужно больше пауз создать прост создаем новые экземпляры классов Event"""
























